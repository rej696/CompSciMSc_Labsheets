\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}
\tikzset{
  ->,
  >=stealth',
  node distance=3cm,
  every state/.style={thick, fill=gray!10},
  initial text=$ $,
}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\usepackage{geometry}
\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}

\title{Problem Sheet 3}
\author{Rowan Saunders}
\begin{document}

\begin{titlepage}
	\maketitle
\end{titlepage}

\section{Regular Languages and Regular Expressions}
\subsection{Regular Operations}
The Union operation is defined as follows:

\begin{quote}
	For two languages $L_1, L_2 \subseteq \Sigma^\ast$, the \textbf{union} of
	these languages is denoted $L_1 \cup L_2$, and is defined analogously to sets.
	i.e. $L_1 \cup L_2$ contains all strings that are either members of $L_1$ or
	members $L_2$.
\end{quote}

The Concatenation operation is defined as follows:

\begin{quote}
	For two languages $L_1, L_2 \subseteq \Sigma^\ast$, their
	\textbf{concatenation}, which is denoted $L_1 \circ L_2$ (alternatively $L_1
		L_2$, is the language given by $L_1 \circ L_2 = \{uv | u \in L_1, v \in L_2 \}$
\end{quote}

An Concatenation example: Let the following both be languages defined over the alphabet $\{a, b\}$
\begin{align*}
	L_1 & = \{a^n | n = 1,2,3...\}, \\
	L_2 & = \{b^m | m = 1,2,3...\}
\end{align*}
Then:
$$ L_1 \circ L_2 = \{a^nb^m | n = 1,2,..., m=1,2,...\}$$
So
\begin{align*}
	aab & \in L_1 \circ L_2    \\
	bab & \notin L_1 \circ L_2
\end{align*}

Therefore, If $L=\{a^nb^m\}$, then $L^2 = L \circ L = \{a^nb^ma^lb^k\}$

The Kleene Star, or simply star operation is a unary operation, which has been
encountered before as $\Sigma^\ast$, which is the set of all strings in a given
alphabet $\Sigma$.

\begin{quote}
	Given a language $L$, the \textbf{Kleene star} is defined as:
	$$L^\ast=\{w_1w_2...w_n|w_i\in L, n = 0,1,...\}$$
	i.e.
	$$L^\ast=\{\varepsilon\} \cup L \cup L^2 \cup L^3 \cup ...$$
\end{quote}

A Kleene star example:
$$L = \{a^nb^m\}, L^\ast = \{a^{n_1}b^{m_1}a^{n_2}b^{m_2}...a^{n_k}b^{n_k}\}$$

If $L = \{a, b\}$ over $\Sigma = \{a, b\}$, then $L^\ast = \Sigma^\ast$

These three operations are called regular operations, because if you apply them
to regular languages, the results are regular too.

This represents the following Theorem:
\begin{quote}
	The class of regular languages is closed under the operations union,
	concatenation, and star. i.e. if $L_1$ and $L_2$ are regular languages, then
	the following languages are also regular:
	\begin{align*}
		\text{a)} & \quad L_1 \cup L_2                         \\
		\text{b)} & \quad L_1 \circ L_2                        \\
		\text{c)} & \quad L_1^\ast \quad (\text{and} L_2^\ast)
	\end{align*}
\end{quote}

The method for proving this theorem is to construct automata that accept these
languages $(L_1, L_2, a, b, c)$

\subsection{Proof that Union Operation is Regular}
Therefore, the proof that the Union operation is regular is as follows
\begin{quote}
	Assume we have regular languages $L_1$ and $L_2$. As they are regular, there
	must be finite automata $N_1$ and $N_2$ which accept these languages
	respectively. We wish to show that $L_1 \cup L_2$ is regular, and we do this
	by creating an NFA that accepts this language.
\end{quote}

The following NFAs can be constructed for $N_1$ (\emph{Figure \ref{fig:n1}}),
$N_2$ (\emph{Figure \ref{fig:n2}}) and $N_1 \cup N_2$ (\emph{Figure
	\ref{fig:n1un2}}). It makes no difference as to whether we use NFAs or DFAs,
however NFAs are often simpler to draw and document:

\begin{itemize}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s) {$s_1$};
			      \node[state, right of=s] (q) {$?$};
			      \node[state, accepting, right of=q] (r) {$r_1$};

			      % transitions
			      \draw (s) edge[above] node{} (q)
			      (q) edge[above] node{} (r);

		      \end{tikzpicture}
		      \caption{$N_1$}
		      \label{fig:n1}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s) {$s_2$};
			      \node[state, right of=s] (q) {$?$};
			      \node[state, accepting, right of=q] (r) {$r_2$};

			      % transitions
			      \draw (s) edge[above] node{} (q)
			      (q) edge[above] node{} (r);

		      \end{tikzpicture}
		      \caption{$N_2$}
		      \label{fig:n2}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s0) {$s_0$};
			      \node[state, above right of=s0] (s1) {$s_1$};
			      \node[state, right of=s1] (q1) {$?$};
			      \node[state, accepting, right of=q1] (r1) {$r_1$};
			      \node[state, below right of=s0] (s2) {$s_2$};
			      \node[state, right of=s2] (q2) {$?$};
			      \node[state, accepting, right of=q2] (r2) {$r_2$};

			      % transitions
			      \draw (s0) edge[left] node{$\varepsilon$} (s1)
			      (s0) edge[left] node{$\varepsilon$} (s2)
			      (s1) edge[above] node{} (q1)
			      (q1) edge[above] node{} (r1)
			      (s2) edge[above] node{} (q2)
			      (q2) edge[above] node{} (r2);

		      \end{tikzpicture}
		      \caption{$N_1 \cup N_2$}
		      \label{fig:n1un2}
	      \end{figure}
\end{itemize}

Let $N_1=(Q_1,\Sigma,\delta_1,s_1,F_1)$ and $N_2=(Q_2,\Sigma,\delta_2,s_2,F_2)$
be non-deterministic finite automata which recognise $L_1$ and $L_2$
respectively.

We Construct $N=(Q,\Sigma,\delta,s_0,F)$ which recognises $L_1 \cup L_2$, where:

\begin{itemize}
	\item[] $Q = Q_1 \cup Q_2 \cup \{s_0\}$
	\item[] $\Sigma$ is the alphabet
	\item[] $\delta(q,a) =
		      \begin{cases}
			      \delta_1 (q,a) & q\in Q_1                         \\
			      \delta_2 (q,a) & q \in Q_2                        \\
			      \{s_1, s_2\}   & q=s_0 \text{ and } a=\varepsilon \\
			      \emptyset      & \text{otherwise}
		      \end{cases}$
	\item[] $s_0$ is the initial state
	\item[] $F = F_1 \cup F_2$
\end{itemize}

This completes the proof for closure of regular languages under the union
operation.

\newpage
\subsection{Proof Concatenation Operator is regular}
The proof that the Concatenation operation is regular is as follows
\begin{quote}
	Assume we have regular languages $L_1$ and $L_2$. As they are regular, there
	must be finite automata $N_1$ and $N_2$ which accept these languages
	respectively. We wish to show that $L_1 \circ L_2$ is regular, and we do this
	by creating an NFA that accepts this language.
\end{quote}

The following NFAs can be constructed for $N_1$ (\emph{Figure \ref{fig:concatn1}}),
$N_2$ (\emph{Figure \ref{fig:concatn2}}) and $N_1 \cup N_2$ (\emph{Figure
	\ref{fig:n1concatn2}}):

\begin{itemize}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s) {$s_1$};
			      \node[state, right of=s] (q) {$?$};
			      \node[state, accepting, right of=q] (r) {$r_1$};

			      % transitions
			      \draw (s) edge[above] node{} (q)
			      (q) edge[above] node{} (r);

		      \end{tikzpicture}
		      \caption{$N_1$}
		      \label{fig:concatn1}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s) {$s_2$};
			      \node[state, right of=s] (q) {$?$};
			      \node[state, accepting, right of=q] (r) {$r_2$};

			      % transitions
			      \draw (s) edge[above] node{} (q)
			      (q) edge[above] node{} (r);

		      \end{tikzpicture}
		      \caption{$N_2$}
		      \label{fig:concatn2}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s0) {$s_0$};
			      \node[state, above right of=s0] (s1) {$s_1$};
			      \node[state, right of=s1] (q1) {$?$};
			      \node[state, right of=q1] (r1) {$r_1$};
			      \node[state, below right of=s0] (s2) {$s_2$};
			      \node[state, right of=s2] (q2) {$?$};
			      \node[state, accepting, right of=q2] (r2) {$r_2$};

			      % transitions
			      \draw (s0) edge[left] node{$\varepsilon$} (s1)
			      (r1) edge[above] node{$\varepsilon$} (s2)
			      (s1) edge[above] node{} (q1)
			      (q1) edge[above] node{} (r1)
			      (s2) edge[above] node{} (q2)
			      (q2) edge[above] node{} (r2);

		      \end{tikzpicture}
		      \caption{$N_1 \cup N_2$}
		      \label{fig:n1concatn2}
	      \end{figure}
\end{itemize}

Let $N_1=(Q_1,\Sigma,\delta_1,s_1,F_1)$ and $N_2=(Q_2,\Sigma,\delta_2,s_2,F_2)$
be non-deterministic finite automata which recognise $L_1$ and $L_2$
respectively.

We Construct $N=(Q,\Sigma,\delta,s_0,F)$ which recognises $L_1 \circ L_2$, where:

\begin{itemize}
	\item[] $Q = Q_1 \cup Q_2 \cup \{s_0\}$
	\item[] $\Sigma$ is the alphabet
	\item[] $\delta(q,a) =
		      \begin{cases}
			      \delta_1 (q,a) & q\in Q_1                         \\
			      \delta_2 (q,a) & q \in Q_2                        \\
			      \{s_1\}        & q=s_0 \text{ and } a=\varepsilon \\
			      \{s_2\}        & q=r_1 \text{ and } a=\varepsilon \\
			      \emptyset      & \text{otherwise}
		      \end{cases}$
	\item[] $s_0$ is the initial state
	\item[] $F = F_2$
\end{itemize}

This completes the proof for closure of regular languages under the
concatenate operation.

\newpage
\subsection{Proof Kleene Star Operator is regular}
The proof that the Kleene Star operation is regular is as follows
\begin{quote}
	Assume we have a regular language $L$. As this is regular, there
	must be finite automata $N$ which accepts this languages
	We wish to show that $L^\ast$ is regular, and we do this
	by creating an NFA that accepts this language.
\end{quote}

The following NFAs can be constructed for $N$ (\emph{Figure \ref{fig:n}})
and $N^\ast$ (\emph{Figure \ref{fig:nstar}}):

\begin{itemize}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s) {$s$};
			      \node[state, right of=s] (q) {$?$};
			      \node[state, accepting, right of=q] (r) {$r$};

			      % transitions
			      \draw (s) edge[above] node{} (q)
			      (q) edge[above] node{} (r);

		      \end{tikzpicture}
		      \caption{$N$}
		      \label{fig:n}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s0) {$s_0$};
			      \node[state, right of=s0] (s) {$s$};
			      \node[state, right of=s] (q) {$?$};
			      \node[state, accepting, right of=q] (r) {$r$};

			      % transitions
			      \draw (s) edge[above] node{} (q)
			      (q) edge[above] node{} (r)
			      (s0) edge[above] node{$\varepsilon$} (s)
			      (r) edge[bend left, below] node{$\varepsilon$} (s0);

		      \end{tikzpicture}
		      \caption{$N^\ast$}
		      \label{fig:nstar}
	      \end{figure}
\end{itemize}

Let $N=(Q,\Sigma,\delta,s,F)$ be non-deterministic finite automata which
recognises $L$.

We Construct
$N_{\text{star}}=(Q_{\text{star}},\Sigma,\delta_{\text{star}},s_0,F_{\text{star}})$
which recognises $L^\ast$, where:

\begin{itemize}
	\item[] $Q_{\text{star}} = Q \cup \{s_0\}$
	\item[] $\Sigma$ is the alphabet
	\item[] $\delta_{\text{star}}(q,a) =
		      \begin{cases}
			      \delta (q,a) & q\in Q                           \\
			      \{s_0\}      & q=r \text{ and } a=\varepsilon   \\
			      \{s\}        & q=s_0 \text{ and } a=\varepsilon \\
			      \emptyset    & \text{otherwise}
		      \end{cases}$
	\item[] $s$ is the initial state
	\item[] $F = \{r\}$
\end{itemize}

This completes the proof for closure of regular languages under the
Kleene Star operation.

\newpage
\section{Regular Expressions}
We define a regular expression recursively. This is also called an inductive
definition.

\begin{quote}
	Given an alphabet $\Sigma$ a \textbf{regular expression} is a string in the
	alphabet $\Sigma \cup \{(, ) , \varepsilon, \emptyset, \cup, \ast \}$, which
	meets the following rules:
	\begin{enumerate}
		\item $\emptyset, \varepsilon$ and $a \in \Sigma$ are regular expressions
		      (called \textbf{atomic regular expressions})
		\item if $\alpha$ and $\beta$ are regular expressions, then the following
		      expressions are regular expressions: $(\alpha \cup \beta), (\alpha\beta),
			      \alpha^\ast$
	\end{enumerate}
	Note that $\alpha\beta$ is the standard string concatenation.
\end{quote}

An example regular expression:

In the alphabet $\Sigma=\{a, b\}$, $(a \cup b) a^\ast$ is a regular expression.
Because:
\begin{itemize}
	\item[] $a$ and $b$ are regular expressions by rule 1
	\item[] So $(a \cup b)$ and $a^\ast$ are regular expressions by rule 2
	\item[] So $(a \cup b) a^\ast$ is a regular expressions by rule 2 again
\end{itemize}

$L(\alpha)$ is the language represented by regular expression $\alpha$

The language of a regular expression is defined by:
\begin{enumerate}
	\item $L(\emptyset) = \emptyset$
	\item $L(\varepsilon) = \varepsilon$
	\item $L(a) = a$ for every $a \in \Sigma$
	\item $L(\alpha \cup \beta) = L(\alpha) \cup L(\beta)$
	\item $L(\alpha\beta) = L(\alpha) \circ L(\beta)$
	\item $L(\alpha^\ast) = (L(\alpha))^\ast$
\end{enumerate}

For example, the language of $(a \cup b) a^\ast$:
\begin{itemize}
	\item[] $L((a \cup b) a^\ast)$
	\item[] $L((a \cup b)) \circ L(a^\ast)$ by rule 5
	\item[] $(L(a) \cup L(b)) \circ (L(a))^\ast$ by rule 4 and rule 6
	\item[] $(\{a\} \cup \{b\}) \circ \{a\}^\ast$ by rule 3
	\item[] $\{a, b\} \circ \{a^n | n \geq 0\}$ by regular operation definitions
\end{itemize}

We can write this as a single set in multiple ways. Here is one example:
$$(a \cup b) a^\ast = \{xa^n|x\in\{a,b\},n\geq0\}$$

We often drop redundant parenthesis, i.e the following left hand examples are
written as the right hand side:
\begin{align*}
	(a \cup (b \cup c)) & = a \cup b \cup c \\
	(a(bc))             & = abc
\end{align*}
There is no loss of meaning, as Union and Concatenation are associative.

Additionally, operations are always applied in a set order. The order of
precedence is:
\begin{enumerate}
	\item Star
	\item Concatenation
	\item Union
\end{enumerate}
Therefore:
\begin{align*}
	ab \cup c & \text{ means } (ab) \cup c \\
	ab^\ast   & \text{ means } a(b^\ast)
\end{align*}

We can use parentheses to change the order, so we could write:
$$a ( b \cup c)$$
$$(ab)^\ast$$


\subsection{Regular Expressions to Finite Automata}
We must now show that Regular Expressions are equivilent to DFA and NFAs, we can
do this with the following Theorem:
\begin{quote}
	\begin{itemize}
		\item[(a)] Any regular expression has an equivalent finite automaton
		\item[(b)] Any finite automaton has an equivalent regular expression
	\end{itemize}
\end{quote}

This Theorem has the following proof:
\begin{quote}
	First, construct NFAs for the atomic regular expressions $\emptyset,
		\varepsilon,$ and $a \in \Sigma$.

	These are as follows
	\begin{itemize}
		\item[]
		      \begin{figure}[H]
			      \centering
			      \begin{tikzpicture}
				      % states
				      \node[state, initial] (s) {};
			      \end{tikzpicture}
			      \caption{NFA that accepts the empty set $\emptyset$}
			      \label{fig:emptyset}
		      \end{figure}
		\item[]
		      \begin{figure}[H]
			      \centering
			      \begin{tikzpicture}
				      % states
				      \node[state, initial, accepting] (s) {};
			      \end{tikzpicture}
			      \caption{NFA that accepts the empty string $\varepsilon$}
			      \label{fig:emptystring}
		      \end{figure}
		\item[]
		      \begin{figure}[H]
			      \centering
			      \begin{tikzpicture}
				      % states
				      \node[state, initial] (s) {};
				      \node[state, accepting, right of=s] (q) {};

				      % transitions
				      \draw (s) edge[above] node{a} (q);
			      \end{tikzpicture}
			      \caption{NFA that accepts a single letter in the alphabet $a \in \Sigma$}
			      \label{fig:ainsigma}
		      \end{figure}
	\end{itemize}
	Now, we can recursively use the earlier proofs of regular operations to build
	NFA which accept $\alpha \cup \beta$, $\alpha\beta$ and $\alpha^\ast$.
\end{quote}

\subsection{Converting Regular Expression into NFA}
We create a NFA from a regular expression by building the finite automata step
by step using the proofs described earlier for the regular operations.

For example for the regular expression $(a \cup b) a^\ast$:
\begin{itemize}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (sa) {};
			      \node[state, accepting, right of=sa] (qa) {};

			      % transitions
			      \draw (sa) edge[above] node{a} (qa);
		      \end{tikzpicture}
		      \caption{NFA to accept $a \in \Sigma$}
		      \label{fig:re2nfa1}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (sb) {};
			      \node[state, accepting, right of=sb] (qb) {};

			      % transitions
			      \draw (sb) edge[above] node{b} (qb);
		      \end{tikzpicture}
		      \caption{NFA to accept $b \in \Sigma$}
		      \label{fig:re2nfa2}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s0) {};
			      \node[state, below right of=s0] (sa) {};
			      \node[state, accepting, right of=sa] (qa) {};
			      \node[state, above right of=s0] (sb) {};
			      \node[state, accepting, right of=sb] (qb) {};

			      % transitions
			      \draw (s0) edge[above] node{$\varepsilon$} (sa)
			      (s0) edge[below] node{$\varepsilon$} (sb)
			      (sa) edge[above] node{a} (qa)
			      (sb) edge[above] node{b} (qb);
		      \end{tikzpicture}
		      \caption{NFA to accept $a \cup b$}
		      \label{fig:re2nfa3}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, accepting, initial] (s0) {};
			      \node[state, right of=s0] (sa) {};
			      \node[state, accepting, right of=sa] (qa) {};

			      % transitions
			      \draw (s0) edge[above] node{$\varepsilon$} (sa)
			      (qa) edge[bend left, below] node{$\varepsilon$} (s0)
			      (sa) edge[above] node{a} (qa);
		      \end{tikzpicture}
		      \caption{NFA to accept $a^\ast$}
		      \label{fig:re2nfa4}
	      \end{figure}
	\item[]
	      \begin{figure}[H]
		      \centering
		      \begin{tikzpicture}
			      % states
			      \node[state, initial] (s0) {};
			      \node[state, below right of=s0] (sa) {};
			      \node[state, right of=sa] (qa) {};
			      \node[state, above right of=s0] (sb) {};
			      \node[state, right of=sb] (qb) {};

			      \node[state, accepting, below right of=qb] (ss) {};
			      \node[state, right of=ss] (ssa) {};
			      \node[state, accepting, right of=ssa] (qsa) {};

			      % transitions
			      \draw (s0) edge[above] node{$\varepsilon$} (sa)
			      (s0) edge[below] node{$\varepsilon$} (sb)
			      (sa) edge[above] node{a} (qa)
			      (sb) edge[above] node{b} (qb)
						(qa) edge[right] node{$\varepsilon$} (ss)
						(qb) edge[right] node{$\varepsilon$} (ss)
			      (ss) edge[above] node{$\varepsilon$} (ssa)
			      (qsa) edge[bend left, below] node{$\varepsilon$} (ss)
			      (ssa) edge[above] node{a} (qsa);
		      \end{tikzpicture}
					\caption{NFA to accept $(a \cup b) \circ a^\ast$}
		      \label{fig:re2nfa5}
	      \end{figure}
\end{itemize}

\subsection{Converting Finite Automata into Regular Expressions}
The following shows that we can convert any Finite Automata into a regular
expression.

Given a finite automaton $N$, we first pre-process the automaton into a
convenient state, in three ways:

We force $N$ to have a single accept state. If it has multiple accept states,
we modify it with a new accept state, add $\varepsilon$ transitions to the new
state, and then remove all accept states but the new one.

We force the initial state to have no ingoing transitions. If this is not
the case, we add a new initial state with an $\varepsilon$ transition to the
old.

Finally, we similarly force the accept state to have no outgoing transitions.
If it does, we can create a new accept state, with an $\varepsilon$
transition.

Next we allow any transition to be labelled with a regular expression rather
than just a single letter. It must be valid, because we can convert the regular
expression into its own NFA.

For example, a transition labelled $a \cup b$ is equivalent to two separate
transitions going from the same state to the same state, labelled a and b. When
an NFA has transitions like these, it is called a \textbf{generalised
non-deterministic finite automaton}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% states
		\node[state] (x) {$x$};
		\node[state, right of=x] (y) {$y$};

		% transitions
		\draw (x) edge[bend left, above] node{$a$} (y)
		(x) edge[bend right, below] node{$b$} (y);
	\end{tikzpicture}
	\begin{tikzpicture}
		% states
		\node[state] (x) {$x$};
		\node[state, right of=x] (y) {$y$};

		% transitions
		\draw (x) edge[above] node{$a \cup b$} (y);
	\end{tikzpicture}
\end{figure}

The general idea of a conversion algorithm is to convert our original NFA with
multiple states, into a generalised NFA, with only two states and a single
transition, $\alpha$, where $\alpha$ is some regular expression. At this point,
$\alpha$ will be the regular expression that represents our original NFA.

We will go through each state, except for the initial state and accept state,
and remove them all one by one, updating the arrows as necessary to ensure we
still represent the same language.

First, convert all instances of states with multiple transitions into unions,
such that there is only either 0 or 1 arrow between any two states.

Now, enumerate all the states from 1 to n, where 1 is the initial state, and n
is the accept state. We will go through each state from 2 to n minus 1, and
consider all of the states that have arcs into and out of this state.

Call the current state $i$, and consider every pair of states that have an
incoming and outgoing arc. We will call these, $j$ and $k$. Note that they might
be the same state. If there is no arc from $i$ to itself, then we add an arc
from $j$ to $k$ which \textbf{concatenates} the transitions. So if the original
transitions are $\alpha$ and $\beta$, we get $\alpha \circ \beta$ as shown:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% states
		\node[state] (j) {$j$};
		\node[state, right of=j] (i) {$i$};
		\node[state, right of=i] (k) {$k$};

		% transitions
		\draw (j) edge[above] node{$\alpha$} (i)
		(i) edge[above] node{$\beta$} (k)
		(j) edge[bend left, above] node{$\alpha\beta$} (k);
	\end{tikzpicture}
\end{figure}

If there is an arc, from $i$ to itself ($\gamma$), then we can concatenate this
into the transition in the middle with a star ($\alpha \circ \gamma^\ast \circ
\beta$):

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% states
		\node[state] (j) {$j$};
		\node[state, right of=j] (i) {$i$};
		\node[state, right of=i] (k) {$k$};

		% transitions
		\draw (j) edge[above] node{$\alpha$} (i)
		(i) edge[above] node{$\beta$} (k)
		(i) edge[loop below] node {$\gamma$} (i)
		(j) edge[bend left, above] node{$\alpha\gamma^\ast\beta$} (k);
	\end{tikzpicture}
\end{figure}

If adding an arc means that there are now multiple transitions from $j$ to $k$,
we combine them with a union, as we did earlier i.e.:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% states
		\node[state] (j) {$j$};
		\node[state, right of=j] (i) {$i$};
		\node[state, right of=i] (k) {$k$};

		% transitions
		\draw (j) edge[above] node{$\alpha$} (i)
		(i) edge[above] node{$\beta$} (k)
		(j) edge[bend right, below] node{$\zeta$} (k)
		(j) edge[bend left, above] node{$\alpha\beta$} (k);
	\end{tikzpicture}
\end{figure}

Goes to:

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		% states
		\node[state] (j) {$j$};
		\node[state, right of=j] (i) {$i$};
		\node[state, right of=i] (k) {$k$};

		% transitions
		\draw (j) edge[above] node{$\alpha$} (i)
		(i) edge[above] node{$\beta$} (k)
		(j) edge[bend left, above] node{$\alpha\beta \cup \zeta$} (k);
	\end{tikzpicture}
\end{figure}

Once we have done this for every pair of states that pass through state $i$, we
finally delete state $i$, and any transitions going to or from it. Now we move
on to the next state. We repeat this until there are only the initial and accept
states left, and a single transition between them labelled with a single regular
expression. We have proven that this regular expression accepts the same
language as the finite automata by construction.


\subsection{NFA to Regular Expression Example}
\subsubsection{Example 1}
NFA for the language $\{0, 1\}$

\begin{itemize}
	\item[] Initial NFA:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (j) {};
				\node[state, right of=j] (i) {};
				\node[state, accepting, right of=i] (k) {};

				% transitions
				\draw (j) edge[above] node{1} (i)
				(i) edge[above] node{0} (k)
				(j) edge[loop below] node{0,1} (j);
			\end{tikzpicture}
		\end{figure}

	\item[] Make sure there are no ingoing transitions to start state:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (s) {};
				\node[state, right of=s] (j) {};
				\node[state, right of=j] (i) {};
				\node[state, accepting, right of=i] (k) {};

				% transitions
				\draw (s) edge[above] node{$\varepsilon$} (j)
				(j) edge[above] node{1} (i)
				(i) edge[above] node{0} (k)
				(j) edge[loop below] node{0,1} (j);
			\end{tikzpicture}
		\end{figure}
	
	\item[] Convert loop to union:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (s) {};
				\node[state, right of=s] (j) {};
				\node[state, right of=j] (i) {};
				\node[state, accepting, right of=i] (k) {};

				% transitions
				\draw (s) edge[above] node{$\varepsilon$} (j)
				(j) edge[above] node{1} (i)
				(i) edge[above] node{0} (k)
				(j) edge[loop below] node{$0 \cup 1$} (j);
			\end{tikzpicture}
		\end{figure}
	
	\item[] Number States:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (s) {1};
				\node[state, right of=s] (j) {2};
				\node[state, right of=j] (i) {3};
				\node[state, accepting, right of=i] (k) {4};

				% transitions
				\draw (s) edge[above] node{$\varepsilon$} (j)
				(j) edge[above] node{1} (i)
				(i) edge[above] node{0} (k)
				(j) edge[loop below] node{$0 \cup 1$} (j);
			\end{tikzpicture}
		\end{figure}
	
	\item[] Consider Paths through 2 (i.e concatenate and star operations)
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (s) {1};
				\node[state, right of=s] (j) {2};
				\node[state, right of=j] (i) {3};
				\node[state, accepting, right of=i] (k) {4};

				% transitions
				\draw (s) edge[above] node{$\varepsilon$} (j)
				(j) edge[above] node{1} (i)
				(i) edge[above] node{0} (k)
				(s) edge[bend left, above] node{$(0 \cup 1)^\ast \circ 1$} (i)
				(j) edge[loop below] node{$0 \cup 1$} (j);
			\end{tikzpicture}
		\end{figure}
	
	\item[] Remove 2
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (s) {1};
				\node[state, right of=s] (i) {3};
				\node[state, accepting, right of=i] (k) {4};

				% transitions
				\draw (s) edge[above] node{$(0 \cup 1)^\ast \circ 1$} (i)
				(i) edge[above] node{0} (k);
			\end{tikzpicture}
		\end{figure}
	
	\item[] Consider Paths through 3 (i.e. concatenate and star operations)
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (s) {1};
				\node[state, right of=s] (i) {3};
				\node[state, accepting, right of=i] (k) {4};

				% transitions
				\draw (s) edge[below] node{$(0 \cup 1)^\ast \circ 1$} (i)
				(s) edge[bend left, above] node{$(0 \cup 1)^\ast \circ 1 \circ 0$} (k)
				(i) edge[above] node{0} (k);
			\end{tikzpicture}
		\end{figure}
	
	\item[] Remove 3
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}[
					node distance=5cm
				]
				% states
				\node[state, initial] (s) {1};
				\node[state, accepting, right of=s] (k) {4};

				% transitions
				\draw (s) edge[above] node{$(0 \cup 1)^\ast \circ 1 \circ 0$} (k);
			\end{tikzpicture}
		\end{figure}
\end{itemize}

\subsubsection{Example 2}
NFA for Any String of X's of Even Length

\begin{itemize}
	\item[] Initial NFA:
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, accepting, initial] (s) {};
				\node[state, right of=s] (q) {};

				% transitions
				\draw (s) edge[bend left, above] node{x} (q)
				(q) edge[bend left, below] node{x} (s);
			\end{tikzpicture}
		\end{figure}

	\item[] Ensure no ingoing transitions to start state
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (p) {};
				\node[state, accepting, right of=p] (s) {};
				\node[state, right of=s] (q) {};

				% transitions
				\draw (s) edge[bend left, above] node{x} (q)
				(q) edge[bend left, below] node{x} (s)
				(p) edge[above] node{$\varepsilon$} (s);
			\end{tikzpicture}
		\end{figure}
	
	\item[] Ensure no outgoing transitions from accept state
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}
				% states
				\node[state, initial] (p) {};
				\node[state, right of=p] (s) {};
				\node[state, right of=s] (q) {};
				\node[state, below of=s, accepting] (r) {};

				% transitions
				\draw (s) edge[bend left, above] node{x} (q)
				(q) edge[bend left, below] node{x} (s)
				(p) edge[above] node{$\varepsilon$} (s)
				(s) edge[right] node{$\varepsilon$} (r);
			\end{tikzpicture}
		\end{figure}

\end{itemize}

\end{document}
